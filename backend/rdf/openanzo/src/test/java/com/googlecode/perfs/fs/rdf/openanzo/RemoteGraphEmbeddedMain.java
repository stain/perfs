package com.googlecode.perfs.fs.rdf.openanzo;import java.util.Date;import java.util.Properties;import org.openanzo.client.DatasetService;import org.openanzo.model.INamedGraph;import org.openanzo.model.impl.query.QueryResult;import org.openrdf.model.URI;import org.openrdf.model.Value;import org.openrdf.query.BindingSet;import org.openrdf.query.TupleQueryResult;/** *  * This simple example instantiates a client DatasetService that communicates * directly with the database in the same JVM. This example works without having * to run any servers. *  * In this example, we use a "RemoteGraph", to access a named graph on the * server via the embedded DatasetService API. *  * @author Ben Szekely ( <a *         href="mailto:ben@cambridgesemantics.com">ben@cambridgesemantics.com *         </a> *  */public class RemoteGraphEmbeddedMain {	public static void main(String[] args) throws Exception {		DatasetService datasetService = null;		// use a try-finally to make sure the datasetServices are closed		// properly		try {			// Read properties file.			Properties embeddedProperties = new Properties();			embeddedProperties					.load(RemoteGraphEmbeddedMain.class							.getResourceAsStream("/openanzo-embeddedclient.properties"));			// instantiate a dataset service			datasetService = new DatasetService(embeddedProperties);			// always use try-finally to make sure the graph is closed.			URI namedGraphURI = datasetService.getValueFactory().createURI(					"http://example.org/ng1");			boolean createIfNecessary = true;			INamedGraph remoteGraph = null;			try {				remoteGraph = datasetService.getRemoteGraph(namedGraphURI,						createIfNecessary);				URI res1 = datasetService.getValueFactory().createURI(						"http://example.org/res1");				URI prop1 = datasetService.getValueFactory().createURI(						"http://example.org/prop1");				// all operations to graphs occur in transactions. If any				// operations are applied outside of a begin/commit, each				// operation is assigned its own transaction. Thus, it is				// recommended that begin/commit subsume as many operations as				// possible.				datasetService.begin();				try {					// do whatever you want to the graph, read write,etc..					remoteGraph.add(res1, prop1, datasetService							.getValueFactory().createLiteral(									new Date().toString()));					remoteGraph.add(res1, prop1, datasetService							.getValueFactory().createLiteral("value2"));					datasetService.commit();				} catch (Exception e) {					datasetService.abort();					throw e;				}				// Push all transaction to the server synchronously. Even before				// this replication occurs, all graphs created with the given				// DatasetService will reflect the committed transactions.				datasetService.getDatasetReplicator().replicate(true);				System.err.println("Sample completed.");				// a basic SPARQL query that executes against the remote graph.				// The INamedGraphWithMetaData objects can be used as normal RDF				// graphs for querying, as well as other purposes.				String query = "SELECT ?s ?p ?o  WHERE { ?s ?p ?o }";				QueryResult result = datasetService						.execQuery(datasetService.getCurrentDataset(), query);				TupleQueryResult results = result.getSelectResult();				while (results.hasNext()) {					BindingSet sol = results.next();					URI s = (URI) sol.getValue("s");					URI p = (URI) sol.getValue("p");					Value o = sol.getValue("o");					System.err.println(datasetService.getValueFactory()							.createStatement(s, p, o));				}			} finally {				if (remoteGraph != null)					remoteGraph.close();			}		} finally {			if (datasetService != null) {				datasetService.close();			}		}	}}